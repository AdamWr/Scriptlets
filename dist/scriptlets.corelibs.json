{
    "version": "1.0.0",
    "scriptlets": [
        {
            "names": [
                "log"
            ],
            "scriptlet": "function(source, args){\nfunction log() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  console.log(args); // eslint-disable-line no-console\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        log.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "abort-on-property-read",
                "ubo-abort-on-property-read.js",
                "abp-abort-on-property-read"
            ],
            "scriptlet": "function(source, args){\nfunction abortOnPropertyRead(source, property) {\n  if (!property) {\n    return;\n  }\n\n  var hit = source.hit ? new Function(source.hit) : function () {};\n  var rid = (0, _randomId.randomId)();\n\n  var abort = function abort() {\n    hit();\n    throw new ReferenceError(rid);\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = (0, _getPropertyInChain.getPropertyInChain)(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain;\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    (0, _setPropertyAccess.setPropertyAccess)(base, prop, {\n      get: abort,\n      set: function set() {}\n    });\n  };\n\n  setChainPropAccess(window, property);\n}\nfunction randomId() {\n  return Math.random().toString(36).substr(2, 9);\n}\nfunction setPropertyAccess(object, property, descriptor) {\n  var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);\n\n  if (currentDescriptor && !currentDescriptor.configurable) {\n    return false;\n  }\n\n  Object.defineProperty(object, property, descriptor);\n  return true;\n}\nfunction getPropertyInChain(base, chain) {\n  var pos = chain.indexOf('.');\n\n  if (pos === -1) {\n    return {\n      base: base,\n      prop: chain\n    };\n  }\n\n  var prop = chain.slice(0, pos);\n  var own = base[prop];\n  chain = chain.slice(pos + 1);\n\n  if (own !== undefined) {\n    return getPropertyInChain(own, chain);\n  }\n\n  Object.defineProperty(base, prop, {\n    configurable: true\n  });\n  return {\n    base: own,\n    prop: prop,\n    chain: chain\n  };\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        abortOnPropertyRead.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "abort-on-property-write",
                "ubo-abort-on-property-write.js",
                "abp-abort-on-property-write"
            ],
            "scriptlet": "function(source, args){\nfunction abortOnPropertyWrite(source, property) {\n  if (!property) {\n    return;\n  }\n\n  var hit = source.hit ? new Function(source.hit) : function () {};\n  var rid = (0, _randomId.randomId)();\n\n  var abort = function abort() {\n    hit();\n    throw new ReferenceError(rid);\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = (0, _getPropertyInChain.getPropertyInChain)(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain;\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    (0, _setPropertyAccess.setPropertyAccess)(base, prop, {\n      set: abort\n    });\n  };\n\n  setChainPropAccess(window, property);\n}\nfunction randomId() {\n  return Math.random().toString(36).substr(2, 9);\n}\nfunction setPropertyAccess(object, property, descriptor) {\n  var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);\n\n  if (currentDescriptor && !currentDescriptor.configurable) {\n    return false;\n  }\n\n  Object.defineProperty(object, property, descriptor);\n  return true;\n}\nfunction getPropertyInChain(base, chain) {\n  var pos = chain.indexOf('.');\n\n  if (pos === -1) {\n    return {\n      base: base,\n      prop: chain\n    };\n  }\n\n  var prop = chain.slice(0, pos);\n  var own = base[prop];\n  chain = chain.slice(pos + 1);\n\n  if (own !== undefined) {\n    return getPropertyInChain(own, chain);\n  }\n\n  Object.defineProperty(base, prop, {\n    configurable: true\n  });\n  return {\n    base: own,\n    prop: prop,\n    chain: chain\n  };\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        abortOnPropertyWrite.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "prevent-setTimeout",
                "ubo-setTimeout-defuser.js"
            ],
            "scriptlet": "function(source, args){\nfunction preventSetTimeout(source, match, delay) {\n  var hit = source.hit ? new Function(source.hit) : function () {};\n  var nativeTimeout = window.setTimeout;\n  delay = parseInt(delay, 10);\n  delay = Number.isNaN(delay) ? null : delay;\n  match = match ? (0, _stringUtils.toRegExp)(match) : (0, _stringUtils.toRegExp)('/.?/');\n\n  var timeoutWrapper = function timeoutWrapper(cb, d) {\n    if ((!delay || d === delay) && match.test(cb.toString())) {\n      hit();\n      return nativeTimeout(function () {}, d);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeTimeout.apply(window, [cb, d].concat(args));\n  };\n\n  window.setTimeout = timeoutWrapper;\n}\nfunction toRegExp(str) {\n  if (str[0] === '/' && str[str.length - 1] === '/') {\n    return new RegExp(str.slice(1, -1));\n  }\n\n  var escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  return new RegExp(escaped);\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        preventSetTimeout.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "prevent-setInterval",
                "ubo-setInterval-defuser.js"
            ],
            "scriptlet": "function(source, args){\nfunction preventSetInterval(source, match, interval) {\n  var hit = source.hit ? new Function(source.hit) : function () {};\n  var nativeInterval = window.setInterval;\n  interval = parseInt(interval, 10);\n  interval = Number.isNaN(interval) ? null : interval;\n  match = match ? (0, _stringUtils.toRegExp)(match) : (0, _stringUtils.toRegExp)('/.?/');\n\n  var intervalWrapper = function intervalWrapper(cb, d) {\n    if ((!interval || d === interval) && match.test(cb.toString())) {\n      hit();\n      return nativeInterval(function () {}, d);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeInterval.apply(window, [cb, d].concat(args));\n  };\n\n  window.setInterval = intervalWrapper;\n}\nfunction toRegExp(str) {\n  if (str[0] === '/' && str[str.length - 1] === '/') {\n    return new RegExp(str.slice(1, -1));\n  }\n\n  var escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  return new RegExp(escaped);\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        preventSetInterval.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "prevent-window-open",
                "ubo-window.open-defuser.js"
            ],
            "scriptlet": "function(source, args){\nfunction preventWindowOpen(source) {\n  var inverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var match = arguments.length > 2 ? arguments[2] : undefined;\n  var nativeOpen = window.open;\n  var hit = source.hit ? new Function(source.hit) : function () {};\n  inverse = inverse ? !+inverse : inverse;\n  match = match ? (0, _stringUtils.toRegExp)(match) : (0, _stringUtils.toRegExp)('/.?/'); // eslint-disable-next-line consistent-return\n\n  var openWrapper = function openWrapper(str) {\n    if (inverse === match.test(str)) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return nativeOpen.apply(window, [str].concat(args));\n    }\n\n    hit();\n  };\n\n  window.open = openWrapper;\n}\nfunction toRegExp(str) {\n  if (str[0] === '/' && str[str.length - 1] === '/') {\n    return new RegExp(str.slice(1, -1));\n  }\n\n  var escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  return new RegExp(escaped);\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        preventWindowOpen.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "abort-current-inline-script",
                "ubo-abort-current-inline-script.js",
                "abp-abort-current-inline-script"
            ],
            "scriptlet": "function(source, args){\nfunction abortCurrentInlineScript(source, property) {\n  var _this = this;\n\n  var search = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var regex = search ? (0, _stringUtils.toRegExp)(search) : null;\n  var rid = (0, _randomId.randomId)();\n  var hit = source.hit ? new Function(source.hit) : function () {};\n\n  var getCurrentScript = function getCurrentScript() {\n    if (!document.currentScript) {\n      var scripts = document.getElementsByTagName('script');\n      return scripts[scripts.length - 1];\n    }\n\n    return document.currentScript;\n  };\n\n  var ourScript = getCurrentScript();\n\n  var abort = function abort() {\n    var scriptEl = getCurrentScript();\n\n    if (scriptEl instanceof HTMLScriptElement && scriptEl.textContent.length > 0 && scriptEl !== ourScript && (!regex || regex.test(scriptEl.textContent))) {\n      hit();\n      throw new ReferenceError(rid);\n    }\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = (0, _getPropertyInChain.getPropertyInChain)(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain;\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    var currentValue = base[prop];\n    (0, _setPropertyAccess.setPropertyAccess)(base, prop, {\n      set: function set(value) {\n        abort();\n        currentValue = value;\n      },\n      get: function get() {\n        abort();\n        return currentValue;\n      }\n    });\n  };\n\n  setChainPropAccess(window, property);\n  var onerrorOriginal = window.onerror; // eslint-disable-next-line consistent-return\n\n  window.onerror = function (error) {\n    if (typeof error === 'string' && error.indexOf(rid) !== -1) {\n      return true;\n    }\n\n    if (onerrorOriginal instanceof Function) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return onerrorOriginal.apply(_this, [error].concat(args));\n    }\n  };\n}\nfunction randomId() {\n  return Math.random().toString(36).substr(2, 9);\n}\nfunction setPropertyAccess(object, property, descriptor) {\n  var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);\n\n  if (currentDescriptor && !currentDescriptor.configurable) {\n    return false;\n  }\n\n  Object.defineProperty(object, property, descriptor);\n  return true;\n}\nfunction getPropertyInChain(base, chain) {\n  var pos = chain.indexOf('.');\n\n  if (pos === -1) {\n    return {\n      base: base,\n      prop: chain\n    };\n  }\n\n  var prop = chain.slice(0, pos);\n  var own = base[prop];\n  chain = chain.slice(pos + 1);\n\n  if (own !== undefined) {\n    return getPropertyInChain(own, chain);\n  }\n\n  Object.defineProperty(base, prop, {\n    configurable: true\n  });\n  return {\n    base: own,\n    prop: prop,\n    chain: chain\n  };\n}\nfunction toRegExp(str) {\n  if (str[0] === '/' && str[str.length - 1] === '/') {\n    return new RegExp(str.slice(1, -1));\n  }\n\n  var escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  return new RegExp(escaped);\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        abortCurrentInlineScript.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "set-constant",
                "ubo-set-constant.js"
            ],
            "scriptlet": "function(source, args){\nfunction setConstant(source, property, value) {\n  if (!property) {\n    return;\n  }\n\n  var constantValue;\n\n  if (value === 'undefined') {\n    constantValue = undefined;\n  } else if (value === 'false') {\n    constantValue = false;\n  } else if (value === 'true') {\n    constantValue = true;\n  } else if (value === 'null') {\n    constantValue = null;\n  } else if (value === 'noopFunc') {\n    constantValue = function constantValue() {};\n  } else if (value === 'trueFunc') {\n    constantValue = function constantValue() {\n      return true;\n    };\n  } else if (value === 'falseFunc') {\n    constantValue = function constantValue() {\n      return false;\n    };\n  } else if (/^\\d+$/.test(value)) {\n    constantValue = parseFloat(value);\n\n    if (Number.isNaN(constantValue)) {\n      return;\n    }\n\n    if (Math.abs(constantValue) > 0x7FFF) {\n      return;\n    }\n  } else if (value === '') {\n    constantValue = '';\n  } else {\n    return;\n  }\n\n  var hit = source.hit ? new Function(source.hit) : function () {};\n  var canceled = false;\n\n  var mustCancel = function mustCancel(value) {\n    if (canceled) {\n      return canceled;\n    }\n\n    canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue;\n    return canceled;\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = (0, _getPropertyInChain.getPropertyInChain)(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain;\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    if (mustCancel(base[prop])) {\n      return;\n    }\n\n    hit();\n    (0, _setPropertyAccess.setPropertyAccess)(base, prop, {\n      get: function get() {\n        return constantValue;\n      },\n      set: function set(a) {\n        if (mustCancel(a)) {\n          constantValue = a;\n        }\n      }\n    });\n  };\n\n  setChainPropAccess(window, property);\n}\nfunction getPropertyInChain(base, chain) {\n  var pos = chain.indexOf('.');\n\n  if (pos === -1) {\n    return {\n      base: base,\n      prop: chain\n    };\n  }\n\n  var prop = chain.slice(0, pos);\n  var own = base[prop];\n  chain = chain.slice(pos + 1);\n\n  if (own !== undefined) {\n    return getPropertyInChain(own, chain);\n  }\n\n  Object.defineProperty(base, prop, {\n    configurable: true\n  });\n  return {\n    base: own,\n    prop: prop,\n    chain: chain\n  };\n}\nfunction setPropertyAccess(object, property, descriptor) {\n  var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);\n\n  if (currentDescriptor && !currentDescriptor.configurable) {\n    return false;\n  }\n\n  Object.defineProperty(object, property, descriptor);\n  return true;\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        setConstant.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "prevent-addEventListener",
                "ubo-addEventListener-defuser.js"
            ],
            "scriptlet": "function(source, args){\nfunction preventAddEventListener(source, event, funcStr) {\n  var hit = source.hit ? new Function(source.hit) : function () {};\n  event = event ? (0, _stringUtils.toRegExp)(event) : (0, _stringUtils.toRegExp)('/.?/');\n  funcStr = funcStr ? (0, _stringUtils.toRegExp)(funcStr) : (0, _stringUtils.toRegExp)('/.?/');\n  var nativeAddEventListener = window.EventTarget.prototype.addEventListener;\n\n  function addEventListenerWrapper(eventName, callback) {\n    if (event.test(eventName.toString()) && funcStr.test(callback.toString())) {\n      hit();\n      return undefined;\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeAddEventListener.apply(this, [eventName, callback].concat(args));\n  }\n\n  window.EventTarget.prototype.addEventListener = addEventListenerWrapper;\n}\nfunction toRegExp(str) {\n  if (str[0] === '/' && str[str.length - 1] === '/') {\n    return new RegExp(str.slice(1, -1));\n  }\n\n  var escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  return new RegExp(escaped);\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        preventAddEventListener.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "prevent-bab",
                "ubo-bab-defuser.js"
            ],
            "scriptlet": "function(source, args){\nfunction preventBab(source) {\n  var _this = this;\n\n  var hit = source.hit ? new Function(source.hit) : function () {};\n  var nativeSetTimeout = window.setTimeout;\n  var babRegex = /\\.bab_elementid.$/;\n\n  window.setTimeout = function (callback) {\n    if (typeof callback !== 'string' || !babRegex.test(callback)) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return nativeSetTimeout.call.apply(nativeSetTimeout, [_this, callback].concat(args));\n    }\n\n    hit();\n  };\n\n  var signatures = [['blockadblock'], ['babasbm'], [/getItem\\('babn'\\)/], ['getElementById', 'String.fromCharCode', 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', 'charAt', 'DOMContentLoaded', 'AdBlock', 'addEventListener', 'doScroll', 'fromCharCode', '<<2|r>>4', 'sessionStorage', 'clientWidth', 'localStorage', 'Math', 'random']];\n\n  var check = function check(str) {\n    for (var i = 0; i < signatures.length; i += 1) {\n      var tokens = signatures[i];\n      var match = 0;\n\n      for (var j = 0; j < tokens.length; j += 1) {\n        var token = tokens[j];\n        var found = token instanceof RegExp ? token.test(str) : str.includes(token);\n\n        if (found) {\n          match += 1;\n        }\n      }\n\n      if (match / tokens.length >= 0.8) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  var nativeEval = window.eval;\n\n  window.eval = function (str) {\n    if (!check(str)) {\n      return nativeEval(str);\n    }\n\n    hit();\n    var bodyEl = document.body;\n\n    if (bodyEl) {\n      bodyEl.style.removeProperty('visibility');\n    }\n\n    var el = document.getElementById('babasbmsgx');\n\n    if (el) {\n      el.parentNode.removeChild(el);\n    }\n  };\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        preventBab.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "nowebrtc",
                "ubo-nowebrtc.js"
            ],
            "scriptlet": "function(source, args){\nfunction nowebrtc(source) {\n  var hit = source.hit ? new Function(source.hit) : function () {};\n  var propertyName = '';\n\n  if (window.RTCPeerConnection) {\n    propertyName = 'RTCPeerConnection';\n  } else if (window.webkitRTCPeerConnection) {\n    propertyName = 'webkitRTCPeerConnection';\n  }\n\n  if (propertyName === '') {\n    return;\n  }\n\n  var log = console.log.bind(console);\n\n  var rtcReplacement = function rtcReplacement(config) {\n    hit();\n    log('Document tried to create an RTCPeerConnection: %o', config);\n  };\n\n  var noop = function noop() {};\n\n  rtcReplacement.prototype = {\n    close: noop,\n    createDataChannel: noop,\n    createOffer: noop,\n    setRemoteDescription: noop\n  };\n  var rtc = window[propertyName];\n  window[propertyName] = rtcReplacement;\n\n  if (rtc.prototype) {\n    rtc.prototype.createDataChannel = function (a, b) {\n      return {\n        close: noop,\n        send: noop\n      };\n    }.bind(null);\n  }\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        nowebrtc.apply(this, updatedArgs);\n    \n}"
        }
    ]
}