{
    "version": "1.0.0",
    "scriptlets": [
        {
            "names": [
                "log"
            ],
            "scriptlet": "function(source, args){\nfunction log() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  console.log(args); // eslint-disable-line no-console\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        log.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "abort-on-property-read",
                "ubo-abort-on-property-read.js",
                "abp-abort-on-property-read"
            ],
            "scriptlet": "function(source, args){\nfunction abortOnPropertyRead(source, property) {\n  if (!property) {\n    return;\n  }\n\n  var hit = (0, _helpers.stringToFunc)(source.hit);\n  var rid = (0, _randomId.randomId)();\n\n  var abort = function abort() {\n    hit();\n    throw new ReferenceError(rid);\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = (0, _getPropertyInChain.getPropertyInChain)(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain;\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    (0, _setPropertyAccess.setPropertyAccess)(base, prop, {\n      get: abort,\n      set: function set() {}\n    });\n  };\n\n  setChainPropAccess(window, property);\n  window.onerror = (0, _helpers.createOnErrorHandler)(rid).bind();\n}\nfunction randomId() {\n  return Math.random().toString(36).substr(2, 9);\n}\nfunction setPropertyAccess(object, property, descriptor) {\n  var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);\n\n  if (currentDescriptor && !currentDescriptor.configurable) {\n    return false;\n  }\n\n  Object.defineProperty(object, property, descriptor);\n  return true;\n}\nfunction getPropertyInChain(base, chain) {\n  var pos = chain.indexOf('.');\n\n  if (pos === -1) {\n    return {\n      base: base,\n      prop: chain\n    };\n  }\n\n  var prop = chain.slice(0, pos);\n  var own = base[prop];\n  chain = chain.slice(pos + 1);\n\n  if (own !== undefined) {\n    return getPropertyInChain(own, chain);\n  }\n\n  Object.defineProperty(base, prop, {\n    configurable: true\n  });\n  return {\n    base: own,\n    prop: prop,\n    chain: chain\n  };\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n}\nfunction createOnErrorHandler(rid) {\n  // eslint-disable-next-line consistent-return\n  var nativeOnError = window.onerror;\n  return function onError(error) {\n    if (typeof error === 'string' && error.indexOf(rid) !== -1) {\n      return true;\n    }\n\n    if (nativeOnError instanceof Function) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return nativeOnError.apply(this, [error].concat(args));\n    }\n\n    return false;\n  };\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        abortOnPropertyRead.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "abort-on-property-write",
                "ubo-abort-on-property-write.js",
                "abp-abort-on-property-write"
            ],
            "scriptlet": "function(source, args){\nfunction abortOnPropertyWrite(source, property) {\n  if (!property) {\n    return;\n  }\n\n  var hit = (0, _helpers.stringToFunc)(source.hit);\n  var rid = (0, _randomId.randomId)();\n\n  var abort = function abort() {\n    hit();\n    throw new ReferenceError(rid);\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = (0, _getPropertyInChain.getPropertyInChain)(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain;\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    (0, _setPropertyAccess.setPropertyAccess)(base, prop, {\n      set: abort\n    });\n  };\n\n  setChainPropAccess(window, property);\n  window.onerror = (0, _helpers.createOnErrorHandler)(rid).bind();\n}\nfunction randomId() {\n  return Math.random().toString(36).substr(2, 9);\n}\nfunction setPropertyAccess(object, property, descriptor) {\n  var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);\n\n  if (currentDescriptor && !currentDescriptor.configurable) {\n    return false;\n  }\n\n  Object.defineProperty(object, property, descriptor);\n  return true;\n}\nfunction getPropertyInChain(base, chain) {\n  var pos = chain.indexOf('.');\n\n  if (pos === -1) {\n    return {\n      base: base,\n      prop: chain\n    };\n  }\n\n  var prop = chain.slice(0, pos);\n  var own = base[prop];\n  chain = chain.slice(pos + 1);\n\n  if (own !== undefined) {\n    return getPropertyInChain(own, chain);\n  }\n\n  Object.defineProperty(base, prop, {\n    configurable: true\n  });\n  return {\n    base: own,\n    prop: prop,\n    chain: chain\n  };\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n}\nfunction createOnErrorHandler(rid) {\n  // eslint-disable-next-line consistent-return\n  var nativeOnError = window.onerror;\n  return function onError(error) {\n    if (typeof error === 'string' && error.indexOf(rid) !== -1) {\n      return true;\n    }\n\n    if (nativeOnError instanceof Function) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return nativeOnError.apply(this, [error].concat(args));\n    }\n\n    return false;\n  };\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        abortOnPropertyWrite.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "prevent-setTimeout",
                "ubo-setTimeout-defuser.js"
            ],
            "scriptlet": "function(source, args){\nfunction preventSetTimeout(source, match, delay) {\n  var hit = (0, _stringUtils.stringToFunc)(source.hit);\n  var nativeTimeout = window.setTimeout;\n  delay = parseInt(delay, 10);\n  delay = Number.isNaN(delay) ? null : delay;\n  match = match ? (0, _stringUtils.toRegExp)(match) : (0, _stringUtils.toRegExp)('/.?/');\n\n  var timeoutWrapper = function timeoutWrapper(cb, d) {\n    if ((!delay || d === delay) && match.test(cb.toString())) {\n      hit();\n      return nativeTimeout(function () {}, d);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeTimeout.apply(window, [cb, d].concat(args));\n  };\n\n  window.setTimeout = timeoutWrapper;\n}\nfunction toRegExp(str) {\n  if (str[0] === '/' && str[str.length - 1] === '/') {\n    return new RegExp(str.slice(1, -1));\n  }\n\n  var escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  return new RegExp(escaped);\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        preventSetTimeout.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "prevent-setInterval",
                "ubo-setInterval-defuser.js"
            ],
            "scriptlet": "function(source, args){\nfunction preventSetInterval(source, match, interval) {\n  var hit = (0, _stringUtils.stringToFunc)(source.hit);\n  var nativeInterval = window.setInterval;\n  interval = parseInt(interval, 10);\n  interval = Number.isNaN(interval) ? null : interval;\n  match = match ? (0, _stringUtils.toRegExp)(match) : (0, _stringUtils.toRegExp)('/.?/');\n\n  var intervalWrapper = function intervalWrapper(cb, d) {\n    if ((!interval || d === interval) && match.test(cb.toString())) {\n      hit();\n      return nativeInterval(function () {}, d);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeInterval.apply(window, [cb, d].concat(args));\n  };\n\n  window.setInterval = intervalWrapper;\n}\nfunction toRegExp(str) {\n  if (str[0] === '/' && str[str.length - 1] === '/') {\n    return new RegExp(str.slice(1, -1));\n  }\n\n  var escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  return new RegExp(escaped);\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        preventSetInterval.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "prevent-window-open",
                "ubo-window.open-defuser.js"
            ],
            "scriptlet": "function(source, args){\nfunction preventWindowOpen(source) {\n  var inverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var match = arguments.length > 2 ? arguments[2] : undefined;\n  var nativeOpen = window.open;\n  var hit = (0, _stringUtils.stringToFunc)(source.hit);\n  inverse = inverse ? !+inverse : inverse;\n  match = match ? (0, _stringUtils.toRegExp)(match) : (0, _stringUtils.toRegExp)('/.?/'); // eslint-disable-next-line consistent-return\n\n  var openWrapper = function openWrapper(str) {\n    if (inverse === match.test(str)) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return nativeOpen.apply(window, [str].concat(args));\n    }\n\n    hit();\n  };\n\n  window.open = openWrapper;\n}\nfunction toRegExp(str) {\n  if (str[0] === '/' && str[str.length - 1] === '/') {\n    return new RegExp(str.slice(1, -1));\n  }\n\n  var escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  return new RegExp(escaped);\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        preventWindowOpen.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "abort-current-inline-script",
                "ubo-abort-current-inline-script.js",
                "abp-abort-current-inline-script"
            ],
            "scriptlet": "function(source, args){\nfunction abortCurrentInlineScript(source, property) {\n  var search = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var regex = search ? (0, _stringUtils.toRegExp)(search) : null;\n  var rid = (0, _randomId.randomId)();\n  var hit = (0, _stringUtils.stringToFunc)(source.hit);\n\n  var getCurrentScript = function getCurrentScript() {\n    if (!document.currentScript) {\n      var scripts = document.getElementsByTagName('script');\n      return scripts[scripts.length - 1];\n    }\n\n    return document.currentScript;\n  };\n\n  var ourScript = getCurrentScript();\n\n  var abort = function abort() {\n    var scriptEl = getCurrentScript();\n\n    if (scriptEl instanceof HTMLScriptElement && scriptEl.textContent.length > 0 && scriptEl !== ourScript && (!regex || regex.test(scriptEl.textContent))) {\n      hit();\n      throw new ReferenceError(rid);\n    }\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = (0, _getPropertyInChain.getPropertyInChain)(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain;\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    var currentValue = base[prop];\n    (0, _setPropertyAccess.setPropertyAccess)(base, prop, {\n      set: function set(value) {\n        abort();\n        currentValue = value;\n      },\n      get: function get() {\n        abort();\n        return currentValue;\n      }\n    });\n  };\n\n  setChainPropAccess(window, property);\n  window.onerror = (0, _helpers.createOnErrorHandler)(rid).bind();\n}\nfunction randomId() {\n  return Math.random().toString(36).substr(2, 9);\n}\nfunction setPropertyAccess(object, property, descriptor) {\n  var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);\n\n  if (currentDescriptor && !currentDescriptor.configurable) {\n    return false;\n  }\n\n  Object.defineProperty(object, property, descriptor);\n  return true;\n}\nfunction getPropertyInChain(base, chain) {\n  var pos = chain.indexOf('.');\n\n  if (pos === -1) {\n    return {\n      base: base,\n      prop: chain\n    };\n  }\n\n  var prop = chain.slice(0, pos);\n  var own = base[prop];\n  chain = chain.slice(pos + 1);\n\n  if (own !== undefined) {\n    return getPropertyInChain(own, chain);\n  }\n\n  Object.defineProperty(base, prop, {\n    configurable: true\n  });\n  return {\n    base: own,\n    prop: prop,\n    chain: chain\n  };\n}\nfunction toRegExp(str) {\n  if (str[0] === '/' && str[str.length - 1] === '/') {\n    return new RegExp(str.slice(1, -1));\n  }\n\n  var escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  return new RegExp(escaped);\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n}\nfunction createOnErrorHandler(rid) {\n  // eslint-disable-next-line consistent-return\n  var nativeOnError = window.onerror;\n  return function onError(error) {\n    if (typeof error === 'string' && error.indexOf(rid) !== -1) {\n      return true;\n    }\n\n    if (nativeOnError instanceof Function) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return nativeOnError.apply(this, [error].concat(args));\n    }\n\n    return false;\n  };\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        abortCurrentInlineScript.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "set-constant",
                "ubo-set-constant.js"
            ],
            "scriptlet": "function(source, args){\nfunction setConstant(source, property, value) {\n  if (!property) {\n    return;\n  }\n\n  var constantValue;\n\n  if (value === 'undefined') {\n    constantValue = undefined;\n  } else if (value === 'false') {\n    constantValue = false;\n  } else if (value === 'true') {\n    constantValue = true;\n  } else if (value === 'null') {\n    constantValue = null;\n  } else if (value === 'noopFunc') {\n    constantValue = function constantValue() {};\n  } else if (value === 'trueFunc') {\n    constantValue = function constantValue() {\n      return true;\n    };\n  } else if (value === 'falseFunc') {\n    constantValue = function constantValue() {\n      return false;\n    };\n  } else if (/^\\d+$/.test(value)) {\n    constantValue = parseFloat(value);\n\n    if (Number.isNaN(constantValue)) {\n      return;\n    }\n\n    if (Math.abs(constantValue) > 0x7FFF) {\n      return;\n    }\n  } else if (value === '') {\n    constantValue = '';\n  } else {\n    return;\n  }\n\n  var hit = (0, _stringUtils.stringToFunc)(source.hit);\n  var canceled = false;\n\n  var mustCancel = function mustCancel(value) {\n    if (canceled) {\n      return canceled;\n    }\n\n    canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue;\n    return canceled;\n  };\n\n  var setChainPropAccess = function setChainPropAccess(owner, property) {\n    var chainInfo = (0, _getPropertyInChain.getPropertyInChain)(owner, property);\n    var base = chainInfo.base;\n    var prop = chainInfo.prop,\n        chain = chainInfo.chain;\n\n    if (chain) {\n      var setter = function setter(a) {\n        base = a;\n\n        if (a instanceof Object) {\n          setChainPropAccess(a, chain);\n        }\n      };\n\n      Object.defineProperty(owner, prop, {\n        get: function get() {\n          return base;\n        },\n        set: setter\n      });\n      return;\n    }\n\n    if (mustCancel(base[prop])) {\n      return;\n    }\n\n    hit();\n    (0, _setPropertyAccess.setPropertyAccess)(base, prop, {\n      get: function get() {\n        return constantValue;\n      },\n      set: function set(a) {\n        if (mustCancel(a)) {\n          constantValue = a;\n        }\n      }\n    });\n  };\n\n  setChainPropAccess(window, property);\n}\nfunction getPropertyInChain(base, chain) {\n  var pos = chain.indexOf('.');\n\n  if (pos === -1) {\n    return {\n      base: base,\n      prop: chain\n    };\n  }\n\n  var prop = chain.slice(0, pos);\n  var own = base[prop];\n  chain = chain.slice(pos + 1);\n\n  if (own !== undefined) {\n    return getPropertyInChain(own, chain);\n  }\n\n  Object.defineProperty(base, prop, {\n    configurable: true\n  });\n  return {\n    base: own,\n    prop: prop,\n    chain: chain\n  };\n}\nfunction setPropertyAccess(object, property, descriptor) {\n  var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);\n\n  if (currentDescriptor && !currentDescriptor.configurable) {\n    return false;\n  }\n\n  Object.defineProperty(object, property, descriptor);\n  return true;\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        setConstant.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "remove-cookie",
                "ubo-cookie-remover.js"
            ],
            "scriptlet": "function(source, args){\nfunction removeCookie(source, match) {\n  var hit = (0, _stringUtils.stringToFunc)(source.hit);\n  var regex = match ? (0, _stringUtils.toRegExp)(match) : (0, _stringUtils.toRegExp)('/.?/');\n\n  var removeCookieFromHost = function removeCookieFromHost(cookieName, hostName) {\n    var cookieSpec = \"\".concat(cookieName, \"=\");\n    var domain1 = \"; domain=\".concat(hostName);\n    var domain2 = \"; domain=.\".concat(hostName);\n    var path = '; path=/';\n    var expiration = '; expires=Thu, 01 Jan 1970 00:00:00 GMT';\n    document.cookie = cookieSpec + expiration;\n    document.cookie = cookieSpec + domain1 + expiration;\n    document.cookie = cookieSpec + domain2 + expiration;\n    document.cookie = cookieSpec + path + expiration;\n    document.cookie = cookieSpec + domain1 + path + expiration;\n    document.cookie = cookieSpec + domain2 + path + expiration;\n    hit();\n  };\n\n  var rmCookie = function rmCookie() {\n    document.cookie.split(';').forEach(function (cookieStr) {\n      var pos = cookieStr.indexOf('=');\n\n      if (pos === -1) {\n        return;\n      }\n\n      var cookieName = cookieStr.slice(0, pos).trim();\n\n      if (!regex.test(cookieName)) {\n        return;\n      }\n\n      var hostParts = document.location.hostname.split('.');\n\n      for (var i = 0; i < hostParts.length - 1; i += 1) {\n        var hostName = hostParts.slice(i).join('.');\n\n        if (hostName) {\n          removeCookieFromHost(cookieName, hostName);\n        }\n      }\n    });\n  };\n\n  rmCookie();\n  window.addEventListener('beforeunload', rmCookie);\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n}\nfunction toRegExp(str) {\n  if (str[0] === '/' && str[str.length - 1] === '/') {\n    return new RegExp(str.slice(1, -1));\n  }\n\n  var escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  return new RegExp(escaped);\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        removeCookie.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "prevent-addEventListener",
                "ubo-addEventListener-defuser.js"
            ],
            "scriptlet": "function(source, args){\nfunction preventAddEventListener(source, event, funcStr) {\n  var hit = (0, _stringUtils.stringToFunc)(source.hit);\n  event = event ? (0, _stringUtils.toRegExp)(event) : (0, _stringUtils.toRegExp)('/.?/');\n  funcStr = funcStr ? (0, _stringUtils.toRegExp)(funcStr) : (0, _stringUtils.toRegExp)('/.?/');\n  var nativeAddEventListener = window.EventTarget.prototype.addEventListener;\n\n  function addEventListenerWrapper(eventName, callback) {\n    if (event.test(eventName.toString()) && funcStr.test(callback.toString())) {\n      hit();\n      return undefined;\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeAddEventListener.apply(this, [eventName, callback].concat(args));\n  }\n\n  window.EventTarget.prototype.addEventListener = addEventListenerWrapper;\n}\nfunction toRegExp(str) {\n  if (str[0] === '/' && str[str.length - 1] === '/') {\n    return new RegExp(str.slice(1, -1));\n  }\n\n  var escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  return new RegExp(escaped);\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        preventAddEventListener.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "prevent-bab",
                "ubo-bab-defuser.js"
            ],
            "scriptlet": "function(source, args){\nfunction preventBab(source) {\n  var _this = this;\n\n  var hit = (0, _helpers.stringToFunc)(source.hit);\n  var nativeSetTimeout = window.setTimeout;\n  var babRegex = /\\.bab_elementid.$/;\n\n  window.setTimeout = function (callback) {\n    if (typeof callback !== 'string' || !babRegex.test(callback)) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return nativeSetTimeout.call.apply(nativeSetTimeout, [_this, callback].concat(args));\n    }\n\n    hit();\n  };\n\n  var signatures = [['blockadblock'], ['babasbm'], [/getItem\\('babn'\\)/], ['getElementById', 'String.fromCharCode', 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', 'charAt', 'DOMContentLoaded', 'AdBlock', 'addEventListener', 'doScroll', 'fromCharCode', '<<2|r>>4', 'sessionStorage', 'clientWidth', 'localStorage', 'Math', 'random']];\n\n  var check = function check(str) {\n    for (var i = 0; i < signatures.length; i += 1) {\n      var tokens = signatures[i];\n      var match = 0;\n\n      for (var j = 0; j < tokens.length; j += 1) {\n        var token = tokens[j];\n        var found = token instanceof RegExp ? token.test(str) : str.includes(token);\n\n        if (found) {\n          match += 1;\n        }\n      }\n\n      if (match / tokens.length >= 0.8) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  var nativeEval = window.eval;\n\n  window.eval = function (str) {\n    if (!check(str)) {\n      return nativeEval(str);\n    }\n\n    hit();\n    var bodyEl = document.body;\n\n    if (bodyEl) {\n      bodyEl.style.removeProperty('visibility');\n    }\n\n    var el = document.getElementById('babasbmsgx');\n\n    if (el) {\n      el.parentNode.removeChild(el);\n    }\n  };\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        preventBab.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "nowebrtc",
                "ubo-nowebrtc.js"
            ],
            "scriptlet": "function(source, args){\nfunction nowebrtc(source) {\n  var hit = (0, _helpers.stringToFunc)(source.hit);\n  var propertyName = '';\n\n  if (window.RTCPeerConnection) {\n    propertyName = 'RTCPeerConnection';\n  } else if (window.webkitRTCPeerConnection) {\n    propertyName = 'webkitRTCPeerConnection';\n  }\n\n  if (propertyName === '') {\n    return;\n  }\n\n  var rtcReplacement = function rtcReplacement(config) {\n    hit(\"Document tried to create an RTCPeerConnection: \".concat(config));\n  };\n\n  var noop = function noop() {};\n\n  rtcReplacement.prototype = {\n    close: noop,\n    createDataChannel: noop,\n    createOffer: noop,\n    setRemoteDescription: noop\n  };\n  var rtc = window[propertyName];\n  window[propertyName] = rtcReplacement;\n\n  if (rtc.prototype) {\n    rtc.prototype.createDataChannel = function (a, b) {\n      return {\n        close: noop,\n        send: noop\n      };\n    }.bind(null);\n  }\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        nowebrtc.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "log-addEventListener",
                "addEventListener-logger.js"
            ],
            "scriptlet": "function(source, args){\nfunction logAddEventListener(source) {\n  var hit = (0, _helpers.stringToFunc)(source.hit);\n  var log = console.log.bind(console);\n  var nativeAddEventListener = window.EventTarget.prototype.addEventListener;\n\n  function addEventListenerWrapper(eventName, callback) {\n    log(\"addEventListener(\\\"\".concat(eventName, \"\\\", \").concat(callback.toString(), \")\"));\n    hit();\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeAddEventListener.apply(this, [eventName, callback].concat(args));\n  }\n\n  window.EventTarget.prototype.addEventListener = addEventListenerWrapper;\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        logAddEventListener.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "log-setInterval",
                "setInterval-logger.js"
            ],
            "scriptlet": "function(source, args){\nfunction logSetInterval(source) {\n  var hit = (0, _helpers.stringToFunc)(source.hit);\n  var nativeSetInterval = window.setInterval;\n  var log = console.log.bind(console);\n\n  function setIntervalWrapper(callback, timeout) {\n    hit();\n    log(\"setInterval(\\\"\".concat(callback.toString(), \"\\\", \").concat(timeout, \")\"));\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeSetInterval.apply(window, [callback, timeout].concat(args));\n  }\n\n  window.setInterval = setIntervalWrapper;\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        logSetInterval.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "log-setTimeout",
                "setTimeout-logger.js"
            ],
            "scriptlet": "function(source, args){\nfunction logSetTimeout(source) {\n  var hit = (0, _helpers.stringToFunc)(source.hit);\n  var nativeSetTimeout = window.setTimeout;\n  var log = console.log.bind(console);\n\n  function setTimeoutWrapper(callback, timeout) {\n    hit();\n    log(\"setTimeout(\\\"\".concat(callback.toString(), \"\\\", \").concat(timeout, \")\"));\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return nativeSetTimeout.apply(window, [callback, timeout].concat(args));\n  }\n\n  window.setTimeout = setTimeoutWrapper;\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        logSetTimeout.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "log-eval"
            ],
            "scriptlet": "function(source, args){\nfunction logEval(source) {\n  var hit = (0, _helpers.stringToFunc)(source.hit);\n  var log = console.log.bind(console); // wrap eval function\n\n  var nativeEval = window.eval;\n\n  function evalWrapper(str) {\n    hit();\n    log(\"eval(\\\"\".concat(str, \"\\\")\"));\n    return nativeEval(str);\n  }\n\n  window.eval = evalWrapper; // wrap new Function\n\n  var nativeFunction = window.Function;\n\n  function FunctionWrapper() {\n    hit();\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    log(\"new Function(\".concat(args.join(', '), \")\"));\n    return nativeFunction.apply(this, [].concat(args));\n  }\n\n  FunctionWrapper.prototype = Object.create(nativeFunction.prototype);\n  FunctionWrapper.prototype.constructor = FunctionWrapper;\n  window.Function = FunctionWrapper;\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        logEval.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "noeval.js",
                "silent-noeval.js",
                "noeval"
            ],
            "scriptlet": "function(source, args){\nfunction noeval(source) {\n  var hit = (0, _helpers.stringToFunc)(source.hit);\n\n  window.eval = function evalWrapper(s) {\n    hit(\"AdGuard has prevented eval:\\n\".concat(s));\n  }.bind();\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        noeval.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "noeval-if.js",
                "prevent-eval-if"
            ],
            "scriptlet": "function(source, args){\nfunction preventEvalIf(source, search) {\n  var hit = (0, _helpers.stringToFunc)(source.hit);\n  search = search ? (0, _helpers.toRegExp)(search) : (0, _helpers.toRegExp)('/.?/');\n  var nativeEval = window.eval;\n\n  window.eval = function (payload) {\n    if (!search.test(payload.toString())) {\n      return nativeEval.call(window, payload);\n    }\n\n    hit(payload);\n    return undefined;\n  }.bind(window);\n}\nfunction toRegExp(str) {\n  if (str[0] === '/' && str[str.length - 1] === '/') {\n    return new RegExp(str.slice(1, -1));\n  }\n\n  var escaped = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n  return new RegExp(escaped);\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        preventEvalIf.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "prevent-fab-3.2.0",
                "fuckadblock.js-3.2.0"
            ],
            "scriptlet": "function(source, args){\nfunction preventFab(source) {\n  var hit = (0, _helpers.stringToFunc)(source.hit);\n  hit();\n\n  var Fab = function Fab() {};\n\n  Fab.prototype.check = _helpers.noop;\n  Fab.prototype.clearEvent = _helpers.noop;\n  Fab.prototype.emitEvent = _helpers.noop;\n\n  Fab.prototype.on = function (a, b) {\n    if (!a) {\n      b();\n    }\n\n    return this;\n  };\n\n  Fab.prototype.onDetected = function () {\n    return this;\n  };\n\n  Fab.prototype.onNotDetected = function (a) {\n    a();\n    return this;\n  };\n\n  Fab.prototype.setOption = _helpers.noop;\n  window.FuckAdBlock = window.BlockAdBlock = Fab; //\n\n  window.fuckAdBlock = window.blockAdBlock = new Fab();\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n}\nfunction noop() {};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        preventFab.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "set-popads-dummy",
                "popads-dummy.js"
            ],
            "scriptlet": "function(source, args){\nfunction setPopadsDummy(source) {\n  var hit = (0, _helpers.stringToFunc)(source.hit);\n  delete window.PopAds;\n  delete window.popns;\n  Object.defineProperties(window, {\n    PopAds: {\n      get: function get() {\n        hit();\n        return {};\n      }\n    },\n    popns: {\n      get: function get() {\n        hit();\n        return {};\n      }\n    }\n  });\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        setPopadsDummy.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "prevent-popads-net",
                "popads.net.js"
            ],
            "scriptlet": "function(source, args){\nfunction preventPopadsNet(source) {\n  var hit = (0, _helpers.stringToFunc)(source.hit);\n  var rid = (0, _helpers.randomId)();\n\n  var throwError = function throwError() {\n    throw new ReferenceError(rid);\n  };\n\n  delete window.PopAds;\n  delete window.popns;\n  Object.defineProperties(window, {\n    PopAds: {\n      set: throwError\n    },\n    popns: {\n      set: throwError\n    }\n  });\n  window.onerror = (0, _helpers.createOnErrorHandler)(rid).bind();\n  hit();\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n}\nfunction createOnErrorHandler(rid) {\n  // eslint-disable-next-line consistent-return\n  var nativeOnError = window.onerror;\n  return function onError(error) {\n    if (typeof error === 'string' && error.indexOf(rid) !== -1) {\n      return true;\n    }\n\n    if (nativeOnError instanceof Function) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return nativeOnError.apply(this, [error].concat(args));\n    }\n\n    return false;\n  };\n}\nfunction randomId() {\n  return Math.random().toString(36).substr(2, 9);\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        preventPopadsNet.apply(this, updatedArgs);\n    \n}"
        },
        {
            "names": [
                "prevent-adfly",
                "adfly-defuser.js"
            ],
            "scriptlet": "function(source, args){\nfunction preventAdfly(source) {\n  var hit = (0, _helpers.stringToFunc)(source.hit);\n\n  var isDigit = function isDigit(data) {\n    return /^\\d$/.test(data);\n  };\n\n  var handler = function handler(encodedURL) {\n    var evenChars = '';\n    var oddChars = '';\n\n    for (var i = 0; i < encodedURL.length; i += 1) {\n      if (i % 2 === 0) {\n        evenChars += encodedURL.charAt(i);\n      } else {\n        oddChars = encodedURL.charAt(i) + oddChars;\n      }\n    }\n\n    var data = (evenChars + oddChars).split('');\n\n    for (var _i = 0; _i < data.length; _i += 1) {\n      if (isDigit(data[_i])) {\n        for (var ii = _i + 1; ii < data.length; ii += 1) {\n          if (isDigit(data[ii])) {\n            // eslint-disable-next-line no-bitwise\n            var temp = parseInt(data[_i], 10) ^ parseInt(data[ii], 10);\n\n            if (temp < 10) {\n              data[_i] = temp.toString();\n            }\n\n            _i = ii;\n            break;\n          }\n        }\n      }\n    }\n\n    data = data.join('');\n    var decodedURL = window.atob(data).slice(16, -16);\n    window.stop();\n    window.onbeforeunload = null;\n    window.location.href = decodedURL;\n  };\n\n  var val; // Do not apply handler more than one time\n\n  var applyHandler = true;\n  var result = (0, _helpers.setPropertyAccess)(window, 'ysmm', {\n    configurable: false,\n    set: function set(value) {\n      if (applyHandler) {\n        applyHandler = false;\n\n        try {\n          if (typeof value === 'string') {\n            handler(value);\n          }\n        } catch (err) {} // eslint-disable-line no-empty\n\n      }\n\n      val = value;\n    },\n    get: function get() {\n      return val;\n    }\n  });\n\n  if (result) {\n    hit();\n  } else {\n    window.console.error('Failed to set up prevent-adfly scriptlet');\n  }\n}\nfunction stringToFunc(str) {\n  /**\n   * Returns arguments of the function\n   * @source https://github.com/sindresorhus/fn-args\n   * @param {function|string} [func] function or string\n   * @returns {string[]}\n   */\n  var getFuncArgs = function getFuncArgs(func) {\n    return func.toString().match(/(?:\\((.*)\\))|(?:([^ ]*) *=>)/).slice(1, 3).find(function (capture) {\n      return typeof capture === 'string';\n    }).split(/, */).filter(function (arg) {\n      return arg !== '';\n    }).map(function (arg) {\n      return arg.replace(/\\/\\*.*\\*\\//, '');\n    });\n  };\n  /**\n  * Returns body of the function\n  * @param {function|string} [func] function or string\n  * @returns {string}\n  */\n\n\n  var getFuncBody = function getFuncBody(func) {\n    var regexp = /(?:(?:\\((?:.*)\\))|(?:(?:[^ ]*) *=>))\\s?({?[\\s\\S]*}?)/;\n    var funcString = func.toString();\n    return funcString.match(regexp)[1];\n  };\n\n  var body = '';\n  var args = '';\n  var hitArgs = getFuncArgs(str);\n\n  if (hitArgs.length > 0) {\n    body = getFuncBody(str);\n    args = hitArgs;\n  }\n\n  if (args && body) {\n    return Function.apply(null, args.concat(body));\n  }\n\n  return str ? new Function(\"(\".concat(str, \")()\")) : function () {};\n}\nfunction setPropertyAccess(object, property, descriptor) {\n  var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);\n\n  if (currentDescriptor && !currentDescriptor.configurable) {\n    return false;\n  }\n\n  Object.defineProperty(object, property, descriptor);\n  return true;\n};\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        preventAdfly.apply(this, updatedArgs);\n    \n}"
        }
    ]
}